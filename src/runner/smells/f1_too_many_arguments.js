// Generated by CoffeeScript 1.6.3
(function() {
  var ReportDecorator, TooManyArgumentsReportDecorator,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  ReportDecorator = require('../report_decorator').ReportDecorator;

  TooManyArgumentsReportDecorator = (function(_super) {
    __extends(TooManyArgumentsReportDecorator, _super);

    function TooManyArgumentsReportDecorator() {
      var ARGUMENT_THRESHOLD, getFunctionName, getReport, parse,
        _this = this;
      TooManyArgumentsReportDecorator.__super__.constructor.apply(this, arguments);
      ARGUMENT_THRESHOLD = 3;
      getFunctionName = function(node) {
        if (node.type === "AssignmentExpression") {
          return node.left.property.name;
        }
        if (node.type === "FunctionDeclaration") {
          return node.id.name;
        }
      };
      getReport = function(node, problem) {
        var functionName, lineNumber;
        functionName = getFunctionName(node);
        lineNumber = node.loc.start.line;
        return "Line " + lineNumber + " in function " + functionName + ": " + problem;
      };
      parse = function(syntax, callback) {
        var message;
        message = 'Too many arguments';
        return _this.traverse(syntax, function(node, prevNode) {
          if (node.type === 'FunctionExpression') {
            if (node.params.length > ARGUMENT_THRESHOLD) {
              return callback(prevNode, message);
            }
          } else if (node.type === 'FunctionDeclaration') {
            if (node.params.length > ARGUMENT_THRESHOLD) {
              return callback(node, message);
            }
          }
        });
      };
      this.process = function(sourceTree) {
        var file, files, name;
        files = sourceTree.getFiles();
        for (name in files) {
          if (!__hasProp.call(files, name)) continue;
          file = files[name];
          parse(file.syntax, function(node, message) {
            var report;
            report = getReport(node, message);
            return sourceTree.addReport(name, report);
          });
        }
        return this.component.process(sourceTree);
      };
    }

    return TooManyArgumentsReportDecorator;

  })(ReportDecorator);

  exports.TooManyArgumentsReportDecorator = TooManyArgumentsReportDecorator;

}).call(this);
