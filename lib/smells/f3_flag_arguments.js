// Generated by CoffeeScript 1.6.3
(function() {
  var FlagArgumentsReportDecorator, ReportDecorator,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  ReportDecorator = require('../report_decorator').ReportDecorator;

  FlagArgumentsReportDecorator = (function(_super) {
    __extends(FlagArgumentsReportDecorator, _super);

    function FlagArgumentsReportDecorator() {
      var checkLastArgument, checkMultipleArguments, checkSingleArgument, doubleNegativeList, getFunctionName, getReport, parse,
        _this = this;
      FlagArgumentsReportDecorator.__super__.constructor.apply(this, arguments);
      getFunctionName = function(node) {
        if (node.callee.type === "Identifier") {
          return node.callee.name;
        }
        if (node.callee.type === "MemberExpression") {
          return node.callee.property.name;
        }
      };
      getReport = function(node, problem) {
        var functionName, lineNumber;
        functionName = getFunctionName(node);
        lineNumber = node.loc.start.line;
        return "  Line " + lineNumber + " in function " + functionName + ": " + problem;
      };
      doubleNegativeList = ["hidden", "caseinsensitive", "disabled"];
      checkSingleArgument = function(node, callback) {
        var args, functionName;
        args = node["arguments"];
        functionName = getFunctionName(node);
        if ((args.length !== 1) || (typeof args[0].value !== "boolean")) {
          return;
        }
        if (functionName.substr(0, 3) !== "set") {
          callback(node, "Boolean literal with a non-setter function");
        }
        return doubleNegativeList.forEach(function(term) {
          if (functionName.toLowerCase().indexOf(term.toLowerCase()) >= 0) {
            return callback(node, "Boolean literal with confusing double-negative");
          }
        });
      };
      checkMultipleArguments = function(node, callback) {
        var args, literalCount;
        args = node["arguments"];
        literalCount = 0;
        args.forEach(function(arg) {
          if (typeof arg.value === "boolean") {
            return literalCount++;
          }
        });
        if (literalCount >= 2) {
          if (literalCount === 2 && args.length === 2) {
            if (args[0].value !== args[1].value) {
              callback(node, "Confusing true vs false");
              return;
            }
          }
          return callback(node, "Multiple Boolean literals");
        }
      };
      checkLastArgument = function(node, callback) {
        var args;
        args = node["arguments"];
        if (args.length < 2) {
          return;
        }
        if (typeof args[args.length - 1].value === "boolean") {
          return callback(node, "Ambiguous Boolean literal as the last argument");
        }
      };
      parse = function(syntax, callback) {
        return _this.traverse(syntax, function(node) {
          if (node.type === "CallExpression") {
            checkSingleArgument(node, callback);
            checkLastArgument(node, callback);
            return checkMultipleArguments(node, callback);
          }
        });
      };
      this.process = function(sourceTree) {
        var file, files, name;
        files = sourceTree.getFiles();
        for (name in files) {
          if (!__hasProp.call(files, name)) continue;
          file = files[name];
          parse(file.syntax, function(node, message) {
            var report;
            report = getReport(node, message);
            return sourceTree.addReport(name, report);
          });
        }
        return this.component.process(sourceTree);
      };
    }

    return FlagArgumentsReportDecorator;

  })(ReportDecorator);

  exports.FlagArgumentsReportDecorator = FlagArgumentsReportDecorator;

}).call(this);
